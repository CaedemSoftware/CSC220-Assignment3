package assignment03PartD;public class CircularDoublyLinkedDeque<T> implements DequeInterface<T> {    private Node first;    private int entries;        public CircularDoublyLinkedDeque(){    first = null;    entries = 0;}        @Override    public void addToFront(T newEntry) {        Node newNode = new Node(newEntry);        newNode.next = first;        if (!isEmpty()) {            newNode.previous = first.previous;            if (first.next == null) {                first.next = newNode;                newNode.previous = first;            }            first.previous = newNode;        }//end if not empty        first = newNode;        entries++;    }    @Override    public void addToBack(T newEntry) {        Node newNode = new Node(newEntry);        newNode.next = first;        if (!isEmpty()) {            if (first.next != null) {                newNode.previous = first.previous;                first.previous.next = newNode;            }            if (first.next == null) {                first.next = newNode;                newNode.previous = first;            }            first.previous = newNode;        }//end if not empty        if (isEmpty()) {            first = newNode;        }        entries++;    }    @Override    public T removeFront() throws EmptyQueueException {        T result = null;        if (first != null) {            result = first.data;            if (entries != 1) {                first = first.next;                first.previous = first.previous.previous;            }            if (entries == 1) {                first = null;            }            entries--;        } else {            throw new EmptyQueueException();        }        return result;    }    @Override    public T removeBack() {        T result = null;        if (first != null) {            result = first.previous.data;            if (entries != 1) {                first.previous = first.previous.previous;                first.previous.next = first;            }            if (entries == 1) {                first = null;            }            entries--;        } else {            throw new EmptyQueueException();        }        return result;    }    @Override    public T getFront() throws EmptyQueueException {        T result = null;        if (first != null) {            result = first.data;        } else {            throw new EmptyQueueException();        }        return result;    }    @Override    public T getBack() throws EmptyQueueException {        T result = null;        if (entries == 1) {            result = first.data;        }        if (!isEmpty()) {            result = first.previous.data;        } else {            throw new EmptyQueueException();        }        return result;    }    @Override    public boolean isEmpty() {        return entries == 0;    }    @Override    public void clear() {        while (!isEmpty()) {            removeFront();        }    }    private class Node {        private T data;        private Node previous;        private Node next;        private Node(T dataPortion) {            this(dataPortion, null, null);        } // end constructor        private Node(T dataPortion, Node nextNode, Node previousNode) {            this.data = dataPortion;            this.next = nextNode;            this.previous = previousNode;        }    } // end Node}//end CDLDeque